//! 求值器核心数据类型定义
//! 
//! 本模块定义了求值器的核心数据结构，遵循 RuntimeObject 设计：
//! - 四种分类：原子值、Rc引用值、Weak引用值、GC引用值
//! - 支持可变操作和垃圾回收
//! - 明确的内存管理策略

use std::collections::HashMap;
use std::rc::Rc;
use std::sync::Weak;
use gc::{Gc, GcCell, Trace, Finalize};

use crate::interpreter::SExpr;

// ============================================================================
// 核心数据结构定义
// ============================================================================

/// 运行时对象核心 - 表示运行时的所有可能对象类型
/// 按照引用类型分为四类：
/// 1. 原子值：integer, float, boolean, nil - 直接存储
/// 2. Rc 引用值：Rc<String> - 强引用，不可变内容
/// 3. Weak 引用值：Weak<BuiltinFunction> - 弱引用，避免循环引用
/// 4. GC 引用值：Gc<Cons>, Gc<Vector>, Gc<Lambda>, Gc<Continuation> - 垃圾回收，支持可变操作
#[derive(Trace, Finalize, Debug, Clone)]
pub enum RuntimeObjectCore {
    // === 1. 原子值（Atomic Objects）- 直接存储 ===
    /// 整数 - 原子值，直接存储
    Integer(i64),
    /// 浮点数 - 原子值，直接存储
    Float(f64),
    /// 有理数 - 原子值，直接存储
    Rational(i64, i64),  // 分子, 分母
    /// 字符 - 原子值，直接存储
    Character(char),
    /// 布尔值 - 原子值，直接存储
    Boolean(bool),
    /// 空列表 - 原子值，直接存储
    Nil,
    
    // === 2. Rc 引用值（Rc Reference Objects）- 强引用 ===
    /// 字符串 - Rc 引用值，不可变内容但可共享
    String(Rc<String>),
    /// 符号 - Rc 引用值，不可变内容但可共享
    Symbol(Rc<String>),
    
    // === 3. Weak 引用值（Weak Reference Objects）- 弱引用 ===
    /// 内置函数 - Weak 引用值，避免循环引用
    BuiltinFunction(Weak<BuiltinFunction>),
    
    // === 4. GC 引用值（GC Reference Objects）- 垃圾回收 ===
    /// 可变列表（cons 结构）- GC 引用值，支持可变操作
    Cons(Gc<MutableCons>),
    /// 可变向量 - GC 引用值，支持可变操作
    Vector(Gc<MutableVector>),
    /// Lambda 函数 - GC 引用值，支持环境可变
    Lambda(Gc<Lambda>),
    /// 续延 - GC 引用值，支持 call/cc
    Continuation(Gc<Continuation>),
}

/// 运行时对象 - 包含核心对象和可选的源表达式
/// RuntimeObject 本身是一个比较小的对象，可以直接 Clone
#[derive(Trace, Finalize, Debug, Clone)]
pub struct RuntimeObject {
    /// 核心运行时对象
    pub core: RuntimeObjectCore,
    /// 可选的源表达式，用于保存计算出该 RuntimeObject 的 SExpr
    pub source: Option<Rc<SExpr>>,
}

// ============================================================================
// 可变数据结构
// ============================================================================

/// 可变 Cons 结构 - 支持 set-car! 和 set-cdr! 操作
#[derive(Trace, Finalize, Debug)]
pub struct MutableCons {
    /// car 部分 - 使用 GcCell 支持可变性
    pub car: GcCell<RuntimeObject>,
    /// cdr 部分 - 使用 GcCell 支持可变性
    pub cdr: GcCell<RuntimeObject>,
}

impl MutableCons {
    /// 创建新的可变 Cons
    pub fn new(car: RuntimeObject, cdr: RuntimeObject) -> Self {
        Self {
            car: GcCell::new(car),
            cdr: GcCell::new(cdr),
        }
    }
    
    /// 获取 car 部分
    pub fn car(&self) -> RuntimeObject {
        self.car.borrow().clone()
    }
    
    /// 获取 cdr 部分
    pub fn cdr(&self) -> RuntimeObject {
        self.cdr.borrow().clone()
    }
    
    /// 设置 car 部分
    pub fn set_car(&self, value: RuntimeObject) {
        *self.car.borrow_mut() = value;
    }
    
    /// 设置 cdr 部分
    pub fn set_cdr(&self, value: RuntimeObject) {
        *self.cdr.borrow_mut() = value;
    }
}

/// 可变向量 - 支持 vector-set! 操作
#[derive(Trace, Finalize, Debug)]
pub struct MutableVector {
    /// 向量元素 - 使用 GcCell 支持可变性
    pub elements: GcCell<Vec<RuntimeObject>>,
}

impl MutableVector {
    /// 创建新的可变向量
    pub fn new(elements: Vec<RuntimeObject>) -> Self {
        Self {
            elements: GcCell::new(elements),
        }
    }
    
    /// 获取向量长度
    pub fn len(&self) -> usize {
        self.elements.borrow().len()
    }
    
    /// 检查向量是否为空
    pub fn is_empty(&self) -> bool {
        self.elements.borrow().is_empty()
    }
    
    /// 获取指定索引的元素
    pub fn get(&self, index: usize) -> Option<RuntimeObject> {
        self.elements.borrow().get(index).cloned()
    }
    
    /// 设置指定索引的元素
    pub fn set(&self, index: usize, value: RuntimeObject) -> Result<(), String> {
        let mut elements = self.elements.borrow_mut();
        if index < elements.len() {
            elements[index] = value;
            Ok(())
        } else {
            Err(format!("Index {} out of bounds for vector of length {}", index, elements.len()))
        }
    }
    
    /// 向向量末尾添加元素
    pub fn push(&self, value: RuntimeObject) {
        self.elements.borrow_mut().push(value);
    }
    
    /// 获取向量的所有元素（克隆）
    pub fn to_vec(&self) -> Vec<RuntimeObject> {
        self.elements.borrow().clone()
    }
}

/// Lambda 函数 - 用户定义的函数
#[derive(Trace, Finalize, Debug)]
pub struct Lambda {
    /// 参数名列表
    pub parameters: Vec<String>,
    /// 函数体（语法结构）
    pub body: Rc<SExpr>,
    /// 闭包环境（可变，用 Gc 包装）
    pub closure: Gc<Environment>,
}

/// 内置函数结构
#[derive(Trace, Finalize, Debug, Clone)]
pub struct BuiltinFunction {
    pub name: String,
    pub arity: FunctionArity,
    pub implementation: BuiltinImpl,
}

/// 续延结构 - 支持 call/cc
#[derive(Trace, Finalize, Debug)]
pub struct Continuation {
    /// 续延函数 - 捕获了必要的上下文（环境、调用栈等）
    pub func: Box<dyn Fn(Gc<RuntimeObject>) -> EvaluateResult>,
}

impl Continuation {
    /// 创建新的续延
    pub fn new<F>(func: F) -> Self 
    where 
        F: Fn(Gc<RuntimeObject>) -> EvaluateResult + 'static
    {
        Self {
            func: Box::new(func),
        }
    }
    
    /// 调用续延函数
    pub fn call(&self, value: Gc<RuntimeObject>) -> EvaluateResult {
        (self.func)(value)
    }
}

// ============================================================================
// 辅助类型定义
// ============================================================================

/// 函数参数个数要求
#[derive(Debug, Clone, PartialEq, Trace, Finalize)]
pub enum FunctionArity {
    /// 固定参数个数
    Exact(usize),
    /// 最少参数个数（支持可变参数）
    AtLeast(usize),
    /// 参数个数范围
    Range(usize, usize),
}

/// 内置函数实现类型
#[derive(Debug, Clone, Trace, Finalize)]
pub struct BuiltinImpl {
    /// 函数实现（接收参数列表，返回结果或错误）
    pub func: fn(&[RuntimeObject]) -> Result<RuntimeObject, EvaluateError>,
}

// ============================================================================
// 环境结构
// ============================================================================

/// 环境结构 - 可变的链式结构，支持变量绑定修改
#[derive(Trace, Finalize, Debug)]
pub struct Environment {
    /// 当前环境的变量绑定表
    pub bindings: HashMap<String, RuntimeObject>,
    /// 上级环境（链式结构）
    pub parent: Option<Gc<Environment>>,
}

impl Environment {
    /// 创建新的空环境
    pub fn new() -> Self {
        Self {
            bindings: HashMap::new(),
            parent: None,
        }
    }
    
    /// 创建带父环境的新环境
    pub fn with_parent(parent: Gc<Environment>) -> Self {
        Self {
            bindings: HashMap::new(),
            parent: Some(parent),
        }
    }
    
    /// 在当前环境中定义变量（返回新环境）
    pub fn define(&self, name: String, value: RuntimeObject) -> Self {
        let mut new_bindings = self.bindings.clone();
        new_bindings.insert(name, value);
        Self {
            bindings: new_bindings,
            parent: self.parent.clone(),
        }
    }
    
    /// 设置变量值（如果变量存在，返回新环境）
    pub fn set(&self, name: &str, value: RuntimeObject) -> Result<Self, String> {
        // 先在当前环境查找
        if self.bindings.contains_key(name) {
            let mut new_bindings = self.bindings.clone();
            new_bindings.insert(name.to_string(), value);
            return Ok(Self {
                bindings: new_bindings,
                parent: self.parent.clone(),
            });
        }
        
        // 递归在父环境查找
        if let Some(parent) = &self.parent {
            let new_parent = parent.set(name, value)?;
            Ok(Self {
                bindings: self.bindings.clone(),
                parent: Some(Gc::new(new_parent)),
            })
        } else {
            Err(format!("Undefined variable: {}", name))
        }
    }
    
    /// 查找变量值（递归向上查找）
    pub fn lookup(&self, name: &str) -> Option<RuntimeObject> {
        // 先在当前环境查找
        if let Some(value) = self.bindings.get(name) {
            return Some(value.clone());
        }
        
        // 递归在父环境查找
        if let Some(parent) = &self.parent {
            parent.lookup(name)
        } else {
            None
        }
    }
}

// ============================================================================
// 调用栈帧结构
// ============================================================================

/// 调用栈帧 - 支持函数调用和续延
#[derive(Trace, Finalize, Debug)]
pub struct Frame {
    /// 当前环境
    pub env: Gc<Environment>,
    /// 续延
    pub continuation: Gc<Continuation>,  // GC 包装的续延函数
    /// 父栈帧
    pub parent: Option<Gc<Frame>>,
}

// ============================================================================
// 求值状态类型
// ============================================================================

/// 尾调用上下文 - 标记当前表达式是否在尾位置
#[derive(Clone, Debug, PartialEq)]
pub enum TailContext {
    /// 在尾位置，可以进行尾调用优化
    TailPosition,
    /// 不在尾位置，需要保留调用上下文
    NonTailPosition,
}

/// 求值状态 - 表示求值过程中的当前状态
#[derive(Debug)]
pub struct EvalState {
    /// 当前调用栈 Frame
    pub frame: Rc<Frame>,
    /// 待求值表达式
    pub expr: Rc<SExpr>,
    /// 尾调用上下文信息（用于尾调用优化）
    pub tail_context: TailContext,
    /// 当前表达式的绑定名称（如果有的话）
    pub binding_name: Option<String>,
}

// ============================================================================
// 求值结果类型
// ============================================================================

/// 求值步骤结果 - 表示单步求值的三种可能结果
#[derive(Debug)]
pub enum EvaluateResult {
    /// 求值完成，返回最终结果（运行时对象）
    Completed(Gc<RuntimeObject>),
    /// 需要继续求值，返回下一个状态
    Continue(Rc<EvalState>),
    /// 求值出错，返回错误信息
    Error(EvaluateError),
}

// ============================================================================
// 错误类型
// ============================================================================

/// 求值错误类型 - 表示求值过程中可能出现的各种错误
#[derive(Debug, Clone, PartialEq)]
pub enum EvaluateError {
    // 语法错误
    InvalidQuoteSyntax {
        expr: Rc<SExpr>,
        message: String,
    },
    InvalidIfSyntax {
        expr: Rc<SExpr>,
        message: String,
    },
    InvalidLambdaSyntax {
        expr: Rc<SExpr>,
        message: String,
    },
    InvalidDefineSyntax {
        expr: Rc<SExpr>,
        message: String,
    },
    InvalidLetSyntax {
        expr: Rc<SExpr>,
        message: String,
    },
    InvalidLetBinding {
        expr: Rc<SExpr>,
        message: String,
    },
    InvalidParameterName {
        expr: Rc<SExpr>,
        name: String,
    },
    InvalidParameterList {
        expr: Rc<SExpr>,
        message: String,
    },
    InvalidArgumentList {
        expr: Rc<SExpr>,
        message: String,
    },
    InvalidExpression {
        expr: Rc<SExpr>,
        message: String,
    },
    
    // 运行时错误
    UndefinedVariable {
        expr: Rc<SExpr>,
        name: String,
    },
    UndefinedFunction {
        expr: Rc<SExpr>,
        name: String,
    },
    NotCallable {
        expr: Rc<SExpr>,
        value: String, // 尝试调用的值的字符串表示
    },
    ArgumentCountMismatch {
        expr: Rc<SExpr>,
        expected: String, // 期望的参数个数描述
        actual: usize,    // 实际的参数个数
    },
    DivisionByZero {
        expr: Rc<SExpr>,
    },
    TypeMismatch {
        expr: Rc<SExpr>,
        expected: String,
        actual: String,
    },
    TypeError {
        expr: Rc<SExpr>,
        expected: String,
        actual: String,
    },
    
    // 系统错误
    StackOverflow {
        expr: Rc<SExpr>,
    },
    OutOfMemory {
        expr: Rc<SExpr>,
    },
    InternalError {
        expr: Rc<SExpr>,
        message: String,
    },
    NotImplemented {
        expr: Rc<SExpr>,
        feature: String,
    },
}

// ============================================================================
// 构造函数实现
// ============================================================================

impl RuntimeObject {
    /// 创建新的运行时对象
    pub fn new(core: RuntimeObjectCore) -> Self {
        Self {
            core,
            source: None,
        }
    }
    
    /// 创建带源表达式的运行时对象
    pub fn with_source(core: RuntimeObjectCore, source: Rc<SExpr>) -> Self {
        Self {
            core,
            source: Some(source),
        }
    }
    
    /// 获取核心对象
    pub fn core(&self) -> &RuntimeObjectCore {
        &self.core
    }
    
    /// 获取源表达式
    pub fn source(&self) -> Option<&Rc<SExpr>> {
        self.source.as_ref()
    }
    
    /// 获取对象类型名称
    pub fn type_name(&self) -> &'static str {
        match &self.core {
            RuntimeObjectCore::Integer(_) => "integer",
            RuntimeObjectCore::Float(_) => "float",
            RuntimeObjectCore::Rational(_, _) => "rational",
            RuntimeObjectCore::Character(_) => "character",
            RuntimeObjectCore::Boolean(_) => "boolean",
            RuntimeObjectCore::Nil => "null",
            RuntimeObjectCore::String(_) => "string",
            RuntimeObjectCore::Symbol(_) => "symbol",
            RuntimeObjectCore::BuiltinFunction(_) => "procedure",
            RuntimeObjectCore::Cons(_) => "pair",
            RuntimeObjectCore::Vector(_) => "vector",
            RuntimeObjectCore::Lambda(_) => "procedure",
            RuntimeObjectCore::Continuation(_) => "continuation",
        }
    }
    
    /// 检查是否为真值
    pub fn is_truthy(&self) -> bool {
        match &self.core {
            RuntimeObjectCore::Boolean(false) => false,
            _ => true,
        }
    }
    
    /// 设置 Cons 的 car 部分
    pub fn set_car(&self, value: RuntimeObject) -> Result<(), String> {
        match &self.core {
            RuntimeObjectCore::Cons(cons) => {
                cons.set_car(value);
                Ok(())
            },
            _ => Err(format!("Expected pair, got {}", self.type_name())),
        }
    }
    
    /// 设置 Cons 的 cdr 部分
    pub fn set_cdr(&self, value: RuntimeObject) -> Result<(), String> {
        match &self.core {
            RuntimeObjectCore::Cons(cons) => {
                cons.set_cdr(value);
                Ok(())
            },
            _ => Err(format!("Expected pair, got {}", self.type_name())),
        }
    }
    
    /// 设置向量元素
    pub fn vector_set(&self, index: usize, value: RuntimeObject) -> Result<(), String> {
        match &self.core {
            RuntimeObjectCore::Vector(vector) => {
                vector.set(index, value)
            },
            _ => Err(format!("Expected vector, got {}", self.type_name())),
        }
    }
}

impl Frame {
    /// 创建新的根栈帧
    pub fn new_root(env: Environment, continuation: Continuation) -> Self {
        Self {
            env: Gc::new(env),
            continuation: Gc::new(continuation),
            parent: None,
        }
    }
    
    /// 创建带父栈帧的新栈帧
    pub fn with_parent(env: Environment, continuation: Continuation, parent: Frame) -> Self {
        Self {
            env: Gc::new(env),
            continuation: Gc::new(continuation),
            parent: Some(Gc::new(parent)),
        }
    }
}

impl EvalState {
    /// 创建新的求值状态
    pub fn new(
        frame: Frame, 
        expr: Rc<SExpr>, 
        tail_context: TailContext,
        binding_name: Option<String>
    ) -> Self {
        Self {
            frame: Rc::new(frame),
            expr,
            tail_context,
            binding_name,
        }
    }
}

impl FunctionArity {
    /// 检查参数个数是否匹配
    pub fn matches(&self, actual: usize) -> bool {
        match self {
            FunctionArity::Exact(expected) => actual == *expected,
            FunctionArity::AtLeast(min) => actual >= *min,
            FunctionArity::Range(min, max) => actual >= *min && actual <= *max,
        }
    }
    
    /// 获取期望参数个数的描述
    pub fn description(&self) -> String {
        match self {
            FunctionArity::Exact(n) => format!("{}", n),
            FunctionArity::AtLeast(n) => format!("at least {}", n),
            FunctionArity::Range(min, max) => format!("{} to {}", min, max),
        }
    }
}

// ============================================================================
// PartialEq 实现
// ============================================================================

impl PartialEq for RuntimeObject {
    fn eq(&self, other: &Self) -> bool {
        match (&self.core, &other.core) {
            // 原子值直接比较
            (RuntimeObjectCore::Integer(a), RuntimeObjectCore::Integer(b)) => a == b,
            (RuntimeObjectCore::Float(a), RuntimeObjectCore::Float(b)) => a == b,
            (RuntimeObjectCore::Rational(a1, a2), RuntimeObjectCore::Rational(b1, b2)) => a1 == b1 && a2 == b2,
            (RuntimeObjectCore::Character(a), RuntimeObjectCore::Character(b)) => a == b,
            (RuntimeObjectCore::Boolean(a), RuntimeObjectCore::Boolean(b)) => a == b,
            (RuntimeObjectCore::Nil, RuntimeObjectCore::Nil) => true,
            
            // Rc 引用值比较引用是否相等
            (RuntimeObjectCore::String(a), RuntimeObjectCore::String(b)) => Rc::ptr_eq(a, b),
            (RuntimeObjectCore::Symbol(a), RuntimeObjectCore::Symbol(b)) => Rc::ptr_eq(a, b),
            
            // Weak 引用值需要升级为强引用后比较
            (RuntimeObjectCore::BuiltinFunction(a), RuntimeObjectCore::BuiltinFunction(b)) => {
                if let (Some(ra), Some(rb)) = (a.upgrade(), b.upgrade()) {
                    Rc::ptr_eq(&ra, &rb)
                } else {
                    false
                }
            },
            
            // GC 引用值比较引用是否相等
            (RuntimeObjectCore::Cons(a), RuntimeObjectCore::Cons(b)) => Gc::ptr_eq(a, b),
            (RuntimeObjectCore::Vector(a), RuntimeObjectCore::Vector(b)) => Gc::ptr_eq(a, b),
            (RuntimeObjectCore::Lambda(a), RuntimeObjectCore::Lambda(b)) => Gc::ptr_eq(a, b),
            (RuntimeObjectCore::Continuation(a), RuntimeObjectCore::Continuation(b)) => Gc::ptr_eq(a, b),
            
            _ => false,
        }
    }
}

// ============================================================================
// Display 实现 - 用于错误报告和调试
// ============================================================================

impl std::fmt::Display for EvaluateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EvaluateError::UndefinedVariable { name, .. } => {
                write!(f, "Undefined variable: {}", name)
            },
            EvaluateError::UndefinedFunction { name, .. } => {
                write!(f, "Undefined function: {}", name)
            },
            EvaluateError::NotCallable { value, .. } => {
                write!(f, "Value is not callable: {}", value)
            },
            EvaluateError::ArgumentCountMismatch { expected, actual, .. } => {
                write!(f, "Argument count mismatch: expected {}, got {}", expected, actual)
            },
            EvaluateError::DivisionByZero { .. } => {
                write!(f, "Division by zero")
            },
            EvaluateError::TypeMismatch { expected, actual, .. } => {
                write!(f, "Type mismatch: expected {}, got {}", expected, actual)
            },
            EvaluateError::TypeError { expected, actual, .. } => {
                write!(f, "Type error: expected {}, got {}", expected, actual)
            },
            EvaluateError::InvalidQuoteSyntax { message, .. } => {
                write!(f, "Invalid quote syntax: {}", message)
            },
            EvaluateError::InvalidIfSyntax { message, .. } => {
                write!(f, "Invalid if syntax: {}", message)
            },
            EvaluateError::InvalidLambdaSyntax { message, .. } => {
                write!(f, "Invalid lambda syntax: {}", message)
            },
            EvaluateError::InvalidDefineSyntax { message, .. } => {
                write!(f, "Invalid define syntax: {}", message)
            },
            EvaluateError::InvalidLetSyntax { message, .. } => {
                write!(f, "Invalid let syntax: {}", message)
            },
            EvaluateError::InvalidLetBinding { message, .. } => {
                write!(f, "Invalid let binding: {}", message)
            },
            EvaluateError::InvalidParameterName { name, .. } => {
                write!(f, "Invalid parameter name: {}", name)
            },
            EvaluateError::InvalidParameterList { message, .. } => {
                write!(f, "Invalid parameter list: {}", message)
            },
            EvaluateError::InvalidArgumentList { message, .. } => {
                write!(f, "Invalid argument list: {}", message)
            },
            EvaluateError::InvalidExpression { message, .. } => {
                write!(f, "Invalid expression: {}", message)
            },
            EvaluateError::StackOverflow { .. } => {
                write!(f, "Stack overflow")
            },
            EvaluateError::OutOfMemory { .. } => {
                write!(f, "Out of memory")
            },
            EvaluateError::InternalError { message, .. } => {
                write!(f, "Internal error: {}", message)
            },
            EvaluateError::NotImplemented { feature, .. } => {
                write!(f, "Feature not implemented: {}", feature)
            },
        }
    }
}

impl std::error::Error for EvaluateError {}

impl std::fmt::Display for RuntimeObject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match &self.core {
            RuntimeObjectCore::Integer(n) => write!(f, "{}", n),
            RuntimeObjectCore::Float(n) => write!(f, "{}", n),
            RuntimeObjectCore::Rational(num, den) => write!(f, "{}/{}", num, den),
            RuntimeObjectCore::Character(c) => write!(f, "#\\{}", c),
            RuntimeObjectCore::Boolean(b) => write!(f, "{}", if *b { "#t" } else { "#f" }),
            RuntimeObjectCore::Nil => write!(f, "()"),
            RuntimeObjectCore::String(s) => write!(f, "\"{}\"", s),
            RuntimeObjectCore::Symbol(s) => write!(f, "{}", s),
            RuntimeObjectCore::Cons(cons) => {
                write!(f, "({}", cons.car())?;
                let mut current = cons.cdr();
                loop {
                    match &current.core {
                        RuntimeObjectCore::Nil => break,
                        RuntimeObjectCore::Cons(next_cons) => {
                            write!(f, " {}", next_cons.car())?;
                            current = next_cons.cdr();
                        },
                        _ => {
                            write!(f, " . {}", current)?;
                            break;
                        }
                    }
                }
                write!(f, ")")
            },
            RuntimeObjectCore::Vector(vector) => {
                write!(f, "#(")?;
                let elements = vector.to_vec();
                for (i, element) in elements.iter().enumerate() {
                    if i > 0 {
                        write!(f, " ")?;
                    }
                    write!(f, "{}", element)?;
                }
                write!(f, ")")
            },
            RuntimeObjectCore::Lambda(_) => write!(f, "#<procedure>"),
            RuntimeObjectCore::BuiltinFunction(builtin) => {
                if let Some(strong_ref) = builtin.upgrade() {
                    write!(f, "#<procedure:{}>", strong_ref.name)
                } else {
                    write!(f, "#<procedure:builtin>")
                }
            },
            RuntimeObjectCore::Continuation(_) => write!(f, "#<continuation>"),
        }
    }
}

// ============================================================================
// 兼容性类型别名（用于过渡）
// ============================================================================

/// 兼容性类型别名，用于过渡期间
pub type RuntimeValue = RuntimeObject;
